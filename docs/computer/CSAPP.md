# Computer Science！！！

## CSAPP

### 第一部分	程序结构和执行

#### Chapter2	信息的表示和处理

##### 2.1	信息存储

**字节**（byte）是8位的

内存的每个字节都由一个唯一的数字来标识，叫做**地址**（address）。所有可能地址的集合就成为**虚拟地址空间**（virtual address space）

###### 2.1.1	十六进制表示法

**十六进制**（hexadecimal）数：0	1	2	3	4	5	6	7	8	9	A	B	C	D	E	F

在C里，前面加上0x或0X。A~F既可以是大写也可以是小写，甚至前面后面大小写都混合都没关系（以前一直以为必须一致）

其余无必要了解

###### 2.1.2	字数据大小

每个计算机都有**字长**（word size），指明指针数据的**标称大小**（nominal size）。字长决定的最重要的系统参数是虚拟地址空间的最大大小		64位机器就是0~2<sup>64</sup> -1

| 类别   | 名称 | 类型名                | 数据长度 | 取值范围                              |
| ------ | ---- | --------------------- | :------: | ------------------------------------- |
| 整型   |      | int                   |   32位   | -2<sup>31</sup>~2<sup>31</sup>-1      |
| 整型   |      | short[ int ]          |   16位   | -2<sup>15</sup>~2<sup>15</sup>-1      |
| 整型   |      | long[ int ]           |   32位   | -2<sup>31</sup>~2<sup>31</sup>-1      |
| 整型   |      | unsigned[ int ]       |   32位   | 0~2<sup>32</sup>-1                    |
| 整型   |      | unsigned short[ int ] |   16位   | 0~2<sup>16</sup>-1                    |
| 整型   |      | unsigned long[ int ]  |   32位   | 0~2<sup>32</sup>-1                    |
| 字符型 |      | char                  |   8位    | 0~255                                 |
| 浮点型 |      | float                 |   32位   | +-( 10<sup>-38</sup>~10<sup>38</sup>) |
| 浮点型 |      | double                |   64位   | +-(10<sup>-308</sup>~10<sup>38</sup>) |



###### 2.1.3	寻址和字节顺序

[xw-1,xw-2,......x2,x1,x0],xw-1是最高有效位，x0是最低有效位

小端法（little endian）：最低有效字节在最前面（逆着来）

大端法（big endian）：最高有效字节在最前面（顺着来）

双端法（bi-endian）：可以选择二者其一，选择了就定下来了

反汇编器（disassembler）：一种可以确定可执行程序文件所表示的指令序列的工具

C语言可以通过*强制类型转换*（cast）或者*联合*（union）来允许以一种数据类型引用一个对象

###### 2.1.4	表示字符串

###### 2.1.5	表示代码

###### 2.1.6	布尔代数简介

布尔代数（Boolean algebra）

###### 2.1.7	C语言位级运算

~=not	&=and	|=or	^=exclusive or

###### 2.1.8	C语言逻辑运算

||=OR	&&=AND	!=NOT

0=FALSE	1=TRUE

###### 2.1.9	C语言移位运算

<< 左移		>> 右移

对于x>>k，机器支持两种右移：逻辑右移和算术右移。逻辑右移在左边补0，算术补1

对无符号数，右移必须逻辑。对有符号数，看该数正负。正0负1

##### 2.2	整数表示

###### 2.2.1	整型数据类型

| 类别 | 名称 | 类型名                | 数据长度 | 取值范围   |
| ---- | ---- | --------------------- | :------: | ---------- |
| 整型 |      | int                   |   32位   | -231~231-1 |
| 整型 |      | short[ int ]          |   16位   | -215~215-1 |
| 整型 |      | long[ int ]           |   32位   | -231~231-1 |
| 整型 |      | unsigned[ int ]       |   32位   | 0~232-1    |
| 整型 |      | unsigned short[ int ] |   16位   | 0~216-1    |
| 整型 |      | unsigned long[ int ]  |   32位   | 0~232-1    |

取值范围不对称——附属范围比整数大1

###### 2.2.2	无符号数的编码

函数B2U<sub>w</sub>(Binary to Unsigned)
$$
B2U_w(\vec{x})=\sum\limits_{i=0}^{w-1}x_i2^i
$$
函数B2U<sub>w</sub>是一个双射





###### 2.2.3	补码编码

最常见的有符号数的计算机表示方法是**补码**（two's-complement）,字的最高有效位解释为负权（negative weight）,用函数B2T<sub>w</sub>表示
$$
B2T_w(\vec{x})=-x_{w-1}2^{w-1}+\sum\limits_{i=0}^{w-2}x_i2^i
$$
B2T<sub>w</sub>是一个双射

###### 2.2.4.	有符号数无符号数间转换

强制类型转换的结果保持位值不变，只是改变了解释这些位的方式

数值可能会改变，但是位模式不变



###### 2.2.5	有、无符号数

###### 2.2.6	扩展一个数字的位表示

要将无符号数转化为一个更大的数据类型，我们只要简单地在表示的开头添加0，被称为**零扩展**（zero extension）

要将一个补码数字转换为一个更大的数据类型，可以执行一个**符号扩展**（sign extension）



###### 2.2.7	截断数字

##### 2.3	整数运算

###### 2.3.1	无符号加法

###### 2.3.2	补码加法

###### 2.3.3	补码的非

###### 2.3.4	无符号乘法

###### 2.3.5	补码乘法

###### 2.3.6	乘以常数

###### 2.3.7	除以2的幂

##### 2.4	浮点数

###### 2.4.1	二进制小数

###### 2.4.2	IEEE浮点表示

###### 2.4.3	示例

###### 2.4.4	舍入

###### 2.4.5	浮点运算

#### Chapter3	程序的机器级表示

##### 3.1	历史观点

关于Intel的x86处理器的介绍

##### 3.2	程序编码

用Unix命令行编译C程序文件p1.c：

```unix
linux> gcc -Og -o p p1.c
```

hello.c（源程序、文本） -> hello.i （修改后源程序、文本）-> hello.s（汇编程序、文本） -> hello.o（可重定位目标程序、二进制） -> hello（可执行目标程序、二进制）

###### 3.2.1	机器级代码

两种抽象：1.指令集体系结构或指令集架构

​				   2.机器级程序使用的内存地址是虚拟地址

###### 3.2.2	代码示例

欲看到C语言编译器产生的汇编代码：在命令行使用“-S”选项

```
linux>gcc -Og -S mstore.c
```

(对这个代码的解释：

1. 命令分解

- `linux>`: 这是**终端提示符**，不是命令的一部分。它表示系统准备接收命令。你的提示符可能是 `user@hostname:~$` 或其他形式。
- `gcc`: 这是 **GCC 编译器**的主命令。它用于编译 C、C++ 等多种语言。这里它被告知要处理一个 `.c` 文件，所以它会调用 C 语言编译器。
- `-Og`: 这是一个**编译器选项**，用于指定优化级别。
  - `-O` 表示“优化”。
  - `g` 表示“调试（debug）”。
  - `-Og` 的含义是：**进行优化，但保持优化方式不影响调试体验**。这是一种非常适合在开发阶段进行调试的优化级别。
- `-S`: 这是另一个**编译器选项**，它告诉 GCC：**只进行编译和汇编，但不要进行链接**。具体来说，它会完成以下步骤：
  1. **预处理**：处理源代码中的 `#include` 和 `#define` 等预处理指令。
  2. **编译**：将预处理后的 C 语言源代码**翻译成汇编语言（Assembly）**。
  3. **停止**：生成一个汇编语言文件（`.s` 文件）后**停止**，不生成最终的二进制可执行文件。
- `mstore.c`: 这是输入的**源代码文件**，是一个用 **C 语言** 编写的程序。

2. 执行结果

执行这个命令后，GCC 会处理 `mstore.c` 文件，并生成一个名为 `mstore.s` 的新文件。这个 `.s` 文件里面包含的是由 C 代码翻译而成的**汇编语言（Assembly）** 代码。

)

#### Chapter4	处理器体系结构

#### Chapter5	优化程序性能

#### Chapter6	存储器层次结构

### 第二部分	在系统上运行程序

#### Chapter7	链接

#### Chapter8	异常控制流

#### Chapter9	虚拟内存

#### Chapter10	系统级I/O

#### Chapter11	网络编程

#### Chapter12	并发编程
